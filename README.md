# Var 16: NodeJS_Rent_Apartment

**Тема:** Оренда квартир  
**Сутності:** Квартира, параметри квартири, опис  
**Актори:** Хазяїн квартири, клієнт  
**Сценарії використання:**  
**Хазяїн квартири:** Створення/редагування/видалення інформації про квартиру  
**Клієнт:** пошук квартири по параметрам

## Контрольні питання лаб3:
1) **Опишіть механізм наслідування в JavaScript.**  
   Механізм наслідування в JavaScript базується на прототипній моделі. Кожен об'єкт має посилання на свій прототип, яке може бути встановлене за допомогою ```prototype``` властивості функції-конструктора або ```Object.create()``` методу

2) **Яку функцію виконує Express.js?**  
   Express.js - веб-фреймворк, побудований на базі Node.js, який дозволяє розробникам будувати веб-додатки та API швидко і ефективно. Він виконує роль серверної сторони для розробки веб-додатків.

Основна функція Express.js - обробка маршрутів та управління HTTP-запитами та відповідями. Він надає простий інтерфейс для визначення маршрутів, обробки запитів, обробки посередників (middleware) і генерації відповідей на основі запитів.

Express.js дозволяє визначати різні маршрути для різних URL-шляхів та HTTP-методів (GET, POST, PUT, DELETE тощо). Ви можете встановлювати обробники (handlers) для кожного маршруту, які будуть викликатись при отриманні відповідного запиту.

3) **Що таке middleware? Наведіть приклади.**  
   Middleware - це функції в Express.js, які мають доступ до об'єкту запиту ```request```, об'єкту відповіді ```response``` та наступної функції у потоці обробки запиту ```next```. Вони виконуються між обробником запиту і обробником відповіді і можуть виконувати певні дії, які обробляють або модифікують запит або відповідь перед їх передачею далі.

Middleware можна використовувати для виконання різних задач, таких як автентифікація, авторизація, обробка помилок, маніпулювання даними запиту та відповіді, робота з сеансами та багато іншого. Вони дозволяють розбити обробку запиту на декілька кроків та забезпечити більшу гнучкість і перевикористання коду.
```
app.use((req, res, next) => {
  console.log(`${req.method} ${req.url}`);
  next();
});
```  

4) **Яка різниця між використанням шаблонізаторів для відображення і динамічними сторінками на основі JavaScript?**

Різниця між використанням шаблонізаторів для відображення і динамічними сторінками на основі JavaScript полягає у підході до створення та рендерингу веб-сторінок.

***Шаблонізатори для відображення:***  
Шаблонізатори є інструментами, які дозволяють розділити логіку програмування та представлення на стороні сервера. Вони використовуються для генерації статичних HTML-сторінок на основі шаблонів та даних, які передаються з сервера на клієнт. Шаблонізатори використовуються для написання коду на сервері.

При використанні шаблонізаторів, сервер генерує статичну HTML-сторінку на основі шаблону та переданих даних і відправляє її клієнту. Цей підхід дозволяє створювати сторінки з вмістом, який залежить від даних, отриманих з сервера, але рендеринг відбувається на сервері перед відправкою сторінки клієнту.

Прикладом таких шаблонізаторів є EJS.

***Динамічні сторінки на основі JavaScript:***  
Динамічні сторінки на основі JavaScript використовують JavaScript код на стороні клієнта для маніпулювання та зміни веб-сторінок після того, як вони вже були завантажені. Це означає, що клієнт отримує статичний HTML-код з сервера, а потім використовує JavaScript для модифікації сторінки без необхідності перезавантаження всієї сторінки.

За допомогою JavaScript, можна взаємодіяти з DOM (Document Object Model) сторінки, додавати, змінювати або видаляти елементи, здійснювати асинхронні запити до сервера, отримувати та відображати дані на сторінці без перезавантаження. Цей підхід дозволяє створювати більш динамічні та інтерактивні веб-додатки.

5) **Як можна позбутися дублювання елементів сторінок використовуючи шаблонізатори, які повторюються - футер, хедер та інші?**

Багато шаблонізаторів підтримують концепцію часткових шаблонів (partial templates) або інклудів (includes), яка дозволяє включати вміст одного шаблону в інший шаблон. Зазвичай ці часткові шаблони зберігаються в окремих файлів, що дозволяє їх повторно використовувати.

Ось приклад використання часткових шаблонів з використанням синтаксису шаблонізатора EJS:

***footer.ejs:***
```
html

<footer>
  <p>footer</p>
</footer>
```
***header.ejs:***
```
html

<header>
  <h1>header</h1>
</header>
```
***index.ejs:***
```
html

<!DOCTYPE html>
<html>
<head>
  <title>Page</title>
</head>
<body>
  <% include header.ejs %>

  <p>Something</p>

  <% include footer.ejs %>
</body>
</html>
```
## Контрольні питання лаб4:
1) **Чому REST називається саме так?**  
   REST (Representational State Transfer) названий так через свою фундаментальну концепцію - передачу представлення стану ресурсу.

REST орієнтується на принципи, які використовуються у веб-архітектурі, де різні компоненти взаємодіють між собою через стандартні протоколи, такі як HTTP. У цій архітектурі, ресурси (наприклад, дані або функції) виступають в якості основної абстракції, а клієнтські додатки взаємодіють з цими ресурсами через стандартні методи HTTP, такі як GET, POST, PUT і DELETE.

2) **Опишіть поняття ідемпотентності в REST API.**  
   Ідемпотентність в REST API вказує на властивість операцій, де повторне застосування одного і того ж запиту не має побічних ефектів на серверному боці, окрім повторення відповіді. Запити, які відповідають принципу ідемпотентності, не змінюють стану сервера при кожному повторному виклику з тим самим набором параметрів.

***Основні риси ідемпотентності в REST API:***
* ***Повторність:*** Операцію можна безпечно повторити без будь-яких побічних ефектів. Це означає, що незалежно від того, скільки разів запит був викликаний, результат повинен бути тим самим.
* ***Безпечність:*** Ідемпотентна операція не повинна мати побічних ефектів на сервері. Вона не змінює стану сервера, бази даних або інших ресурсів, крім власне відповіді на запит.
* ***Не залежить від порядку:*** Порядок виконання операцій не впливає на їх результат. Результат операції буде однаковим незалежно від порядку виконання запитів.

3) **Опишіть особливості (параметри, кешування, що передається в тілі) кожного з використаних в лабораторній методів HTTP.**  
   ***GET:*** Метод GET використовується для отримання ресурсу з сервера. Він передає параметри запиту через URL-рядок запиту (query string). GET-запити можуть бути кешовані, оскільки їх результати не повинні змінюватись при кожному запиті з тими самими параметрами. Зазвичай, GET-запити не мають тіла (body), оскільки дані передаються через URL-рядок запиту.

***POST:*** Метод POST використовується для створення нового ресурсу на сервері або виконання деяких дій з ним. Він передає дані запиту у тілі (body) запиту. POST-запити не кешуються, оскільки їх результати можуть змінюватись при кожному виклику. POST-запити часто використовуються для відправки форм або завантаження файлів на сервер.

***PUT:*** Метод PUT використовується для оновлення існуючого ресурсу на сервері. Він також передає дані запиту у тілі (body) запиту. PUT-запити повинні бути ідемпотентними, тобто повторне виконання запиту з тими самими даними не повинно мати побічних ефектів на сервері.

***DELETE:*** Метод DELETE використовується для видалення ресурсу на сервері. Він не передає дані у тілі запиту. DELETE-запити також повинні бути ідемпотентними, тобто повторне виконання запиту не повинно мати побічних ефектів на сервері.

4) **Опишіть різницю методів PUT та POST в REST API.**  
   ***Значення URL:*** У методі PUT URL вказує на конкретний ресурс, який має бути оновлений або створений. Наприклад, ```/users/1``` означає, що дані будуть оновлені для користувача з ідентифікатором 1. У методі POST URL може вказувати на загальну адресу, де новий ресурс буде створений, наприклад, ```/users```, а сервер самостійно призначить йому ідентифікатор.

***Ідемпотентність:*** Метод PUT має властивість ідемпотентності, тобто повторне виконання одного й того ж PUT-запиту з тими самими даними не повинно мати побічних ефектів на сервері. Тобто, якщо запит на оновлення вже виконано, повторне застосування PUT-запиту не змінить стан ресурсу. У методу POST ця властивість відсутня, і повторне виконання одного POST-запиту може мати різні наслідки або створювати дублікати ресурсів.

***Семантика:*** Метод PUT використовується для повного оновлення ресурсу. При використанні PUT-запиту, весь ресурс повинен бути переданий в тілі запиту. Якщо будь-які поля ресурсу не вказані у тілі запиту, вони можуть бути видалені або замінені на значення за замовчуванням. Метод POST, з іншого боку, використовується для створення нового ресурсу або виконання деяких дій з ним. При використанні POST-запиту, тіло запиту може містити лише часткову інформацію про ресурс або дані, які використовуються для виконання певних операцій.

5) **На які дії доречно використовувати кешування.**  
   Кешування може бути корисним для покращення продуктивності та зниження навантаження на сервер у випадках, коли дані або ресурси не змінюються часто і можуть бути повторно використані. Кешування може значно покращити продуктивність та швидкість завантаження сторінок.

***Доречно використовувати кешування до:***
* Статичних ресурсів;
* Запитів до баз даних;
* Результатів обчислень;
* API відповідей.

6) **Опишіть як в REST API виглядає адреса для пошуку в списку обʼктів однієї з сутностей. Наприклад, всі предмети, які вивчаються учнем.**  
   У REST API для адреси пошуку в списку об'єктів однієї з сутностей зазвичай використовується шлях (endpoint), який відповідає даному ресурсу.
``` 
GET /students/{student_id}/subjects
```  
7) **Опишіть яку роль відіграють статуси HTTP(2XX, 3XX, 4XX) в REST API.**  
   ***2XX (Successful):*** Ці статуси позначають успішне виконання запиту сервером. Деякі з найпоширеніших статусів 2XX в REST API включають:
* ***200 OK:*** Запит був успішно виконаний, і відповідь містить потрібні дані.
* ***201 Created:*** Запит на створення нового ресурсу був успішно виконаний.
* ***204 No Content:*** Запит був успішно виконаний, але відповідь не містить додаткових даних (зазвичай використовується для успішного видалення ресурсу).  
  ***3XX (Redirection):*** Ці статуси вказують на потребу додаткових дій з боку клієнта для завершення запиту. Найпоширеніші статуси 3XX включають:
* ***301 Moved Permanently:*** Ресурс був переміщений назавжди на нову URL-адресу.
* ***302 Found:*** Ресурс тимчасово знаходиться за іншою URL-адресою.
* ***304 Not Modified:*** Кеш клієнта є актуальним, і ресурс не змінювався з попереднього запиту.
  ***4XX (Client Error):*** Ці статуси вказують на помилки, що виникають через некоректні дані або дії з боку клієнта. Деякі з найпоширеніших статусів 4XX включають:
* ***400 Bad Request:*** Запит відхилено через некоректні дані або неправильний формат запиту.
* ***401 Unauthorized:*** Клієнт не має авторизації для доступу до ресурсу.
* ***404 Not Found:*** Ресурс не знайдений на сервері.
8) **Опишіть підхід HATEOAS.**  
   HATEOAS (Hypermedia as the Engine of Application State) - це архітектурний підхід у розробці RESTful API, який використовує гіпермедіа як рушійний механізм стану додатку. Головна ідея HATEOAS полягає в тому, що сервер повертає відповідь, яка не лише містить запитані дані, але і надає посилання на релевантні дії, які можна виконати над цими даними.
   Основні принципи HATEOAS:

* ***Гіпермедіа як частини відповіді:*** Відповідь сервера повинна містити гіпермедійні посилання на релевантні дії, які можуть бути виконані над повернутими даними. Ці посилання дозволяють клієнтам динамічно взаємодіяти з ресурсами, оскільки вони отримують інформацію про доступні операції.
* ***Незалежність клієнта від структури API:*** Клієнт повинен мати можливість взаємодіяти з API, використовуючи тільки гіпермедійні посилання, без необхідності залежати від зарані встановлених URL-адрес або структури ресурсів. Це забезпечує гнучкість і розширюваність системи.
* ***Відкрита інтерфейсна документація:*** API повинно бути самоописуючим, надаючи клієнтам необхідну інформацію про доступні ресурси, їхні стани та можливі дії. Це може бути досягнуто шляхом використання гіпермедійних форматів, таких як HAL (Hypertext Application Language) або JSON-LD (JSON Linked Data).
```
"id": 1,
"name": "Math",
"links": [
  {
    "rel": "self",
    "href": "/students/1/subjects/1"
  },
  {
    "rel": "grades",
    "href": "/students/1/subjects/1/grades"
  }
]
```  
9) **Опишіть інші підходи для реалізації API.**
   Помимо підходу HATEOAS, є інші підходи та архітектурні стилі, які використовуються для реалізації API. Деякі з них:

* ***RPC (Remote Procedure Call):*** Цей підхід базується на виклику віддалених процедур з використанням мережевого протоколу. Клієнти викликають специфічні методи на сервері, який виконує ці методи і повертає результат клієнту. Наприклад, SOAP (Simple Object Access Protocol) і XML-RPC (XML Remote Procedure Call) - це протоколи, які використовують RPC для взаємодії.
* ***GraphQL:*** Це мова запитів та розв'язок на основі типів, розроблений Facebook. GraphQL дозволяє клієнтам вказати потрібні дані та їх структуру в одному запиті, і сервер поверне лише ті дані, які запитувалися. Цей підхід дозволяє ефективно передавати дані, уникати надлишковості та зменшувати кількість запитів до сервера.
* ***Falcor:*** Це JavaScript-бібліотека, розроблена Netflix, яка дозволяє клієнтам отримувати дані з сервера в ефективному форматі JSON Graph. Запити до сервера включають шляхи до потрібних даних, і сервер повертає лише запитані дані, використовуючи один або кілька запитів.

## Контрольні питання лаб5:
1) **Опишіть різницю між реляційними та документо-орієнтованими базами даних.**
   Реляційні бази даних (РБД) і документо-орієнтовані бази даних (ДОБД) є двома різними типами баз даних з різними моделями даних і підходами до зберігання та організації інформації. Основні відмінності між ними включають:
* ***Модель даних:*** РБД використовують табличну модель даних, де дані організовані у взаємозв'язки між таблицями, використовуючи ключі. У РБД використовуються схеми даних, які визначають структуру таблиць та зв'язки між ними. З іншого боку, ДОБД використовують документи, такі як JSON або XML, для зберігання даних. Кожен документ може мати внутрішню структуру, а зв'язки між документами можуть бути виражені за допомогою вкладених документів або посилань.
* ***Гнучкість схеми:*** РБД мають жорстку схему, де структура даних передбачена заздалегідь і може змінюватися лише за допомогою міграцій схеми. У ДОБД схема є гнучкою або навіть відсутня, що дозволяє зберігати різнорідні дані в одному документі без необхідності зміни структури.
* ***Запити та мови запитів:*** РБД використовують мови запитів на основі SQL (Structured Query Language), які дозволяють виконувати складні операції з даними, такі як об'єднання, фільтрація, сортування та агрегація. ДОБД, зазвичай, надають мову запитів на основі документів, яка дозволяє вибирати, оновлювати та видаляти документи за допомогою більш наближених до коду запитів.
* ***Масштабованість:*** За рахунок своєї структури, РБД зазвичай добре підходять для комплексних операцій з багатьма зв'язаними таблицями та для великих обсягів даних. ДОБД частіше використовуються для ситуацій, коли потрібна гнучкість в зберіганні та організації невизначених або змінних структур даних.
2) **Опишіть поняття транзакцій. Чи є вони в реляційних та документо-орієнтованих базах даних?**
   Транзакція є логічною одиницею роботи в базі даних, яка складається з одного або кількох запитів. Вона визначає послідовність операцій зчитування та запису, які повинні бути виконані як єдина атомарна операція. Транзакції забезпечують надійність та цілісність даних, дозволяючи виконувати операції бази даних в безпечному та незалежному від однієї одиниці виміру способі.

Реляційні бази даних (РБД) мають вбудовану підтримку транзакцій. Транзакційна підтримка в РБД зазвичай забезпечує такі властивості ACID (Atomicity, Consistency, Isolation, Durability), що гарантують атомарність, консистентність, ізольованість та стійкість транзакцій.

У документо-орієнтованих базах даних (ДОБД), підтримка транзакцій може варіюватися. Деякі ДОБД можуть мати обмежену підтримку транзакцій або навіть не мати її зовсім. Однак, деякі ДОБД, такі як MongoDB, надають певну рівень підтримки транзакцій, де користувач може групувати кілька операцій в рамках однієї транзакції та забезпечувати атомарність цих операцій.

3) **Які є способи реалізувати ManyToMany звʼязок в базах даних?**
   Існує кілька способів реалізації зв'язку "багато-до-багатьох" (Many-to-Many) в базах даних. Ось декілька з них:
* ***Використання проміжної таблиці:*** Цей спосіб полягає у створенні додаткової таблиці, яка встановлює зв'язок між двома таблицями зв'язку. Ця таблиця зазвичай містить зовнішні ключі, що посилаються на первинні ключі таблиць, які потрібно зв'язати. Кожен запис у проміжній таблиці представляє зв'язок між конкретними записами у двох вихідних таблицях.
* ***Використання полів з масивами:*** Деякі бази даних, такі як PostgreSQL та MongoDB, підтримують поле з масивом. В цьому випадку, у кожного запису в одній таблиці може бути поле-масив, що містить посилання на записи в іншій таблиці. Це дозволяє встановлювати багато-до-багатьох зв'язки без створення проміжної таблиці.
* ***Використання комбінації проміжної таблиці та полів з масивами:*** Іноді можна використовувати комбінацію обох підходів. Наприклад, використовуючи проміжну таблицю для встановлення зв'язку між двома таблицями, а потім використовуючи поле з масивом для зберігання додаткових даних, пов'язаних з цим зв'язком.

4) **Опишіть особливості БД Redis. Чому вона швидка? Де її краще використовувати?**
   ***Особливості БД Redis:***
* ***Швидкість:*** Redis є дуже швидкою базою даних завдяки своїй унікальній архітектурі. Вона зберігає дані в оперативній пам'яті, що дозволяє досягти низького часу відгуку та високої продуктивності. Redis також оптимізована для виконання широкого спектру операцій з даними, таких як рядки, хеші, списки, набори і множини.
* ***Низька латентність:*** Redis має низьку латентність завдяки збереженню даних в оперативній пам'яті та використанню асинхронних операцій введення-виведення. Це робить Redis ідеальним вибором для використання в реальному часі та високонавантажених додатках, які вимагають миттєвої відповіді.
* ***Кешування:*** Redis є потужним інструментом для кешування даних. Він може зберігати результати запитів до бази даних або результати обчислень, що дозволяє зменшити навантаження на інші джерела даних і покращити продуктивність додатків.
* ***Розширюваність:*** Redis підтримує розподілену архітектуру, що дозволяє масштабувати базу даних горизонтально. Ви можете використовувати кластери Redis для розподілення навантаження та забезпечення високої доступності.
* ***Використання:*** Redis можна використовувати в різних сценаріях, таких як кешування, сесії користувачів, черги повідомлень, реалізація розподілених блокувань та багато іншого. Вона підходить для широкого спектру застосувань, включаючи веб-додатки, аналітику даних, гральну індустрію та системи реального часу.
